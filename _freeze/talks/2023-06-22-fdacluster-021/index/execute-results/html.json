{
  "hash": "cd3682caa164dad931c222c4799a1f0d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"fdacluster\"\nsubtitle: \"An R package for joint clustering and alignment of functional data\"\nauthor:\n  - name: L. Bellanger, A. Stamm\n    affiliation: Department of Mathematics Jean Leray, UMR CNRS 6629, Nantes University, France\n    corresponding: true\n    orcid: 0000-0002-8725-3654\n  - name: L.M. Sangalli, P. Secchi, S. Vantini\n    affiliation: MOX - Department of Mathematics, Politecnico di Milano, Italy\nformat:\n  revealjs:\n    footer: \"Rencontres R 2023 - Avignon - <aymeric.stamm@cnrs.fr>\"\n    slide-number: true\n    logo: logo-lmjl.png\n    date: 2023-06-22\n    theme: dark\n    scrollable: true\nbibliography: references.bib\nimage: rr2023.png\n---\n\n\n\n\n# Title explanation\n\n## Clustering\n\n- *Unlabeled data*: observations are not assigned to pre-existing groups;\n- *Goal*: group together individuals or observations that share common features \nwhile ensuring the following property: \n  - observations **within** a group must be as similar as possible, \n  - observations **between** groups (belonging to different groups) must be as <span color=\"red\">different</span> as possible.\n\n## Clustering methods {.smaller}\n\n::: {.callout}\n## Centroid-based clustering\nClusters are represented by a *central value* or \n*centroid*. This centroid might not necessarily be one of the observations. \nThese methods (e.g. `k-means`) operate in an iterative fashion in which the \nnotion of similarity is derived by how close an observation is to the centroid \nof the cluster.\n:::\n\n::: {.callout}\n## Hierarchical clustering\nObservations that are closer in the data space are \nmore related (similar) than observations that are far from each other. Clusters \nare formed by connecting observations according to their distance and clusters \nare allowed to be merged or splitted according to a cluster-based distance.\n:::\n\n::: {.callout}\n## Density-based clustering\nSearch the data space for areas of high density of \nobservations (e.g. `DBSCAN`). Clusters are defined as the areas of higher \ndensity within the data space compared to other regions. Observations in the \nsparse areas are usually considered to be noise and/or border points.\n:::\n\n<!-- ::: {.callout} -->\n<!-- ## Model-based clustering -->\n<!-- Observations should be assigned to the same cluster  -->\n<!-- if they have been drawn from the same distribution. These models have a strong  -->\n<!-- theoretical foundation, however they often suffer from overfitting. The most  -->\n<!-- famous method uses Gaussian mixture models. -->\n<!-- ::: -->\n\n::: {.callout-tip}\n## A common ingredient\nAll methods but model-based rely on the ability to quantify closeness / distance between observations.\n:::\n\n## Functional data - Visual definition\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-1-1.png){fig-align='center' width=960}\n:::\n:::\n\n\nData source: Berkeley Growth Study data [@tuddenham1954physical;@ramsay2006functional]\n\n## Functional data - Derivatives {.smaller}\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-2-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n::: {.callout-important}\n## What if we did not know gender membership?\n\n- Common peak of growth velocity shortly after birth\n- Another smaller peak at puberty occurring:\n  - At different ages for girls and for boys;\n  - At different ages for each individual.\n:::\n\n# Functional clustering\n\n## Functional data - Notations\n\n- We consider a random variable $X$ which takes values in $F = \\{ f: \\mathcal{D} \\to \\mathcal{M} \\}$.\n- The domain $\\mathcal{D}$ of the functions in $F$ is a subset of $\\mathbb{R}$. Typically $\\mathcal{D} = \\mathbb{R}$ or $\\mathcal{D} = [a, b]$.\n- The co-domain $\\mathcal{M}$ of the functions in $F$ can be univariate or multivariate and can be either a Euclidean space or more generally a manifold. Typically, $\\mathcal{M} =\n\\mathbb{R}^p$.\n- The space $F$ is equipped with a metric $d$ so that $(F, d)$ is a metric space.\n\n## Functional data - A simpler example {.smaller}\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-3-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n*Data source:* @sangalli2010k.\n\n## Functional data - Clustering {.smaller}\n\n:::: {.columns}\n\n::: {.column width=\"40%\"}\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-4-1.png){width=960}\n:::\n:::\n\n:::\n\n::: {.column width=\"60%\"}\n\nSolution 1:\n$$\n\\begin{cases}\nd_A^2(f, g) = d^2(f, g) \\\\\nd_C^2(f, g) = d_A^2(f, g)\n\\end{cases}\n$$\n\nSolutions 2 & 3:\n$$\n\\begin{cases}\nd_A^2(f, g) = \\min_{h \\in W} d^2(f \\circ h, g) \\\\\nd_C^2(f, g) = d_A^2(f, g)\n\\end{cases}\n$$\n\n$$\n\\begin{cases}\nd_A^2(f, g) = \\min_{h \\in W} d^2(f \\circ h, g) \\\\\nd_C^2(f, g) = \\int_{\\mathcal{D}} \\left[ h^\\star(t) - t \\right]^2 dt \\\\\n\\end{cases}\n$$\nwith $h^\\star(t) = \\arg \\min_{h \\in W} d^2(f \\circ h, g)$.\n:::\n\n::::\n\n## Registration of curves {.smaller}\n\nThe following properties on the functional space $F$, its metric $d$ and the set $W$ of warping functions considered for curve registration must be satisfied for a mathematically consistent registration setup [@vantini2012on]:\n\n(a) $F = \\{ f: \\mathcal{D} \\to \\mathcal{M} \\}$ is a metric space equipped with a metric $d: F \\times F \\to \\mathbb{R}^+$;\n\n(b) $W$ is a subgroup — with respect to ordinary composition $\\circ$ — of the group of the continuous automorphisms of $\\mathcal{D}$;\n\n(c) $\\forall f \\in F$ and $\\forall h \\in W$, we have that $f \\circ h \\in F$;\n\n(d) Given any couple of elements $f_1, f_2 \\in F$ and an element $h \\in W$, the distance between $f_1$ and $f_2$ is invariant under the composition of $f_1$ and $f_2$ with $h$, i.e.:\n\n$$\nd(f_1, f_2) = d(f_1 \\circ h, f_2 \\circ h).\n$$\n\nWe will refer to this property as $W$-invariance of $d$.\n\n## The case $\\mathcal{D} = \\mathbb{R}$ {.smaller}\n\nIn this situation, it is not possible to perform registration over $\\mathbb{R}$ and most of the time we use $W$ to be the set of affine warping functions i.e. $W = \\{ h: h(t) = at+b \\}$.\n\nIn this setting, it is tempting to equip $F$ with the $L^2$-distance:\n$$\nd_{L^2}^2(f, g) = \\int_\\mathbb{R} \\left\\| f(t) - g(t) \\right\\|_{\\mathbb{R}^p}^2 dt.\n$$\n\nThe $L^2$-distance is however **not affine-invariant**:\n\n$$\nd_{L^2}^2(f \\circ h, g \\circ h) = \\frac{1}{a} d_{L^2}^2(f, g)\n$$\n\nA proper normalization can make it affine-invariant such as:\n$$\nd(f, g) = \\frac{d_{L^2}(f, g)}{\\| f \\|_{L^2} + \\| g \\|_{L^2}}\n$$\n\n## The case $\\mathcal{D} = [a, b]$ {.smaller}\n\nIn this situation, it is possible to perform registration over the set $W$ of **all boundary-preserving warping functions** by using the *square-root slope function* (SRSF) framework [@tucker2013generative] under the assumption that all functions $f \\in F$ are **absolutely continuous**. In this case, the SRSF of a function $f \\in F$ which reads:\n\n$$\n\\begin{array}{rccl}\nq_f : & \\mathbb{R} & \\to & \\mathbb{R}^p \\\\\n& t & \\mapsto & \\frac{\\dot{f}(t)}{\\sqrt{ \\| \\dot{f}(t) \\|_{\\mathbb{R}^p} }}, \n\\end{array}\n$$\nis square-integrable and thus belong to $L^2([a,b], \\mathbb{R}^p)$.\n\nWe can therefore define:\n$$\nd(f, g) = d_{L^2}(q_f, q_g),\n$$\nand one can show that $d$ is invariant under any boundary-preserving warping.\n\n## Funct. $k$-means [@sangalli2010k] {.smaller}\n\n::: {.callout}\n## Initialization\n\nChoose $k$ initial observations as cluster centroids.\n:::\n\n::: {.callout}\n## Align observations\nPerform registration of all observed curves on each cluster centroid.\n:::\n\n::: {.callout}\n## Assign observations to closest centroid\n\nAssign each observed curve to the cluster with smallest distance to its center. This involves solving a constrained mixed integer and linear programming problem to ensure that no requested cluster will be empty.\n:::\n\n::: {.callout}\n## Update cluster centroids\nRecompute each cluster centroid given the newly assigned observations. Since the solution to the registration problem is not unique, the *unique* centroid is computed according to recommendations in @vantini2012on to minimize total variation. If $f_0$ is a computed centroid, then define the cluster centroid as\n$$\n\\widehat{f_0} = \\arg \\min_{f \\in [f_0]} \\sum_{i=1}^n d^2(f_i, f),\n$$\nwhich is achieved for some warping function $h^\\star$ which needs to be further applied to all observations in that cluster.\n:::\n\n## Funct. hierarchical clustering {.smaller}\n\n::: {.callout}\n## Distance matrix computation\nCompute the matrix $D$ of pairwise distances between curves minimizing over the selected class $W$ of warping functions.\n:::\n\n::: {.callout}\n## Dendrogram computation\nApply traditional approaches to hierarchical clustering on $D$ (either agglomerative or divisive) to build a hierarchy of possible clustering partitions of the data (dendrogram).\n:::\n\n::: {.callout}\n## Assign observations to clusters\n- Cut the dendrogram to form $k$ clusters and, in each cluster;\n- Register all curves to centroid via funct. $1$-mean clustering.\n:::\n\n::: {.callout}\n## Update distance matrix\nUpdate the distance matrix $D$ using the registered curves from previous step with no further registration. This is used for final calculations of WSS and silhouettes.\n:::\n\n::: {.callout-note}\n## Functional DBSCAN\nAdapting DBSCAN to functional data follows the same principles.\n:::\n\n# The `R` package [**fdacluster**](https://astamm.github.io/fdacluster/index.html) {background-image=\"images/fdacluster_hex_trans.png\" background-size=10% background-position=\"100% 0%\"}\n\n## On CRAN (or almost) {.smaller}\n\nYou can install the official version from CRAN via:\n``` r\ninstall.packages(\"fdacluster\")\n```\nor you can opt to install the development version from [GitHub](https://github.com/) with:\n``` r\n# install.packages(\"remotes\")\nremotes::install_github(\"astamm/fdacluster\")\n```\n\n::: {.callout-note}\n## Website\n<https://astamm.github.io/fdacluster/index.html>\n:::\n\n::: {.callout-caution}\n## Test it out now!\nIf you want to test the package right now, use the development version.\n:::\n\n## Features {.smaller}\n\n1. A dedicated `S3` class for storing results of clustering with amplitude and\nphase separation;\n2. Implementations of k-means, HAC and DBSCAN methods for functional data;\n3. Built-in parallelization;\n4. Tools for comparing various clustering strategies:\n\n    - [`compare_caps()`](https://astamm.github.io/fdacluster/reference/compare_caps.html): generates an object of class `mcaps()` containing [`caps`](https://astamm.github.io/fdacluster/reference/caps.html) objects for several clustering strategies;\n    - [`plot()`](https://astamm.github.io/fdacluster/reference/plot.mcaps.html) and [`autoplot()`](https://astamm.github.io/fdacluster/reference/autoplot.mcaps.html) S3 specialized methods for `mcaps` objects.\n\n5. Integration within the R fda landscape: input grids and curves can be\n\n    - vectors, matrices, arrays; or,\n    - `fd` objects from the [**fda**](https://cran.r-project.org/web/packages/fda/index.html) package; or,\n    - `funData` or `multiFunData` objects from the [**funData**](https://cran.r-project.org/web/packages/funData/index.html) package.\n\n## Built-in parallelization\n\n- Achieved via the [**futureverse**](https://www.futureverse.org)\nframework;\n- Possibility of displaying a progress bar.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(future)\nlibrary(progressr)\nhandlers(\"rstudio\") # Defines RStudio progress bar style\nplan(multisession, workers = parallelly::availableCores(omit = 1)) # Turns ON parallelization\nwith_progress(\n  # User-defined code for clustering\n  out1 <- fdahclust(\n    x = x,\n    y = t(y1),\n    n_clusters = 2,\n    metric = \"normalized_l2\",\n    warping_class = \"affine\",\n    cluster_on_phase = TRUE\n  )\n)\nplan(sequential) # Turns OFF parallelization\n```\n:::\n\n\n## The [`caps`](https://astamm.github.io/fdacluster/reference/caps.html) class\n\n::: {.r-stack}\n\n::: {.fragment .fade-in-then-out}\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 14\n $ original_curves    : num [1:93, 1, 1:31] 12.44 18.13 12.02 16.92 8.51 ...\n $ original_grids     : num [1:93, 1:31] 1 1 1 1 1 1 1 1 1 1 ...\n $ aligned_grids      : num [1:93, 1:31] 1.527 1.275 1.845 0.937 2.262 ...\n $ center_curves      : num [1:2, 1, 1:31] 20.3 20.6 16.5 17.2 12.6 ...\n $ center_grids       : num [1:2, 1:31] 0.26 0.195 0.898 0.862 1.537 ...\n $ n_clusters         : num 2\n $ memberships        : Named int [1:93] 1 1 1 1 1 1 1 1 1 1 ...\n  ..- attr(*, \"names\")= chr [1:93] \"1\" \"2\" \"3\" \"4\" ...\n $ distances_to_center: num [1:93] 0.02969 0.04775 0.01153 0.00876 0.01807 ...\n $ silhouettes        : num [1:93] 0.754 0.739 0.84 0.826 0.805 ...\n $ amplitude_variation: num 0.0635\n $ total_variation    : num 0.146\n $ n_iterations       : num 0\n $ call_name          : chr \"fdahclust\"\n $ call_args          :List of 20\n  ..$ x                           : symbol x\n  ..$ y                           : language t(y1)\n  ..$ n_clusters                  : num 2\n  ..$ is_domain_interval          : logi FALSE\n  ..$ transformation              : chr \"identity\"\n  ..$ warping_class               : chr \"affine\"\n  ..$ centroid_type               : chr \"mean\"\n  ..$ metric                      : chr \"normalized_l2\"\n  ..$ cluster_on_phase            : logi TRUE\n  ..$ linkage_criterion           : chr \"complete\"\n  ..$ use_verbose                 : logi FALSE\n  ..$ warping_options             : language c(0.15, 0.15)\n  ..$ maximum_number_of_iterations: int 100\n  ..$ number_of_threads           : int 1\n  ..$ parallel_method             : int 0\n  ..$ distance_relative_tolerance : num 0.001\n  ..$ use_fence                   : logi FALSE\n  ..$ check_total_dissimilarity   : logi TRUE\n  ..$ compute_overall_center      : logi FALSE\n  ..$ centroid_extra              : num 0\n - attr(*, \"class\")= chr [1:2] \"caps\" \"list\"\n```\n\n\n:::\n:::\n\n:::\n\n::: {.fragment .fade-in-then-out}\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(out1, type = \"amplitude\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-7-1.png){width=960}\n:::\n\n```{.r .cell-code}\n# p <- ggplot2::autoplot(out1, type = \"amplitude\")\n```\n:::\n\n:::\n\n::: {.fragment .fade-in-then-out}\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(out1, type = \"phase\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-8-1.png){width=960}\n:::\n:::\n\n:::\n\n::: {.fragment .fade-in-then-out}\n\n::: {.cell}\n\n```{.r .cell-code}\ndiagnostic_plot(out1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-9-1.png){width=960}\n:::\n:::\n\n:::\n\n:::\n\n## Common interface for clustering functions {.smaller}\n\n:::: {.columns}\n\n::: {.column width=\"48%\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1-7\"}\nfdakmeans(\n  x,\n  y = NULL,\n  warping_class = c(\"affine\", \"dilation\", \"none\", \"shift\", \"srsf\"),\n  centroid_type = \"mean\",\n  metric = c(\"l2\", \"pearson\"),\n  cluster_on_phase = FALSE,\n  n_clusters = 1L,\n  seeds = NULL,\n  seeding_strategy = c(\"kmeans++\", \"exhaustive-kmeans++\", \"exhaustive\", \"hclust\")\n)\n```\n:::\n\n:::\n\n::: {.column width=\"48%\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1-7\"}\nfdahclust(\n  x,\n  y = NULL,\n  warping_class = c(\"affine\", \"dilation\", \"none\", \"shift\", \"srsf\"),\n  centroid_type = \"mean\",\n  metric = c(\"l2\", \"pearson\"),\n  cluster_on_phase = FALSE,\n  n_clusters = 1L,\n  linkage_criterion = c(\"complete\", \"average\", \"single\", \"ward.D2\")\n)\n```\n:::\n\n:::\n\n::::\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1-7\"}\nfdadbscan(\n  x,\n  y = NULL,\n  warping_class = c(\"affine\", \"dilation\", \"none\", \"shift\", \"srsf\"),\n  centroid_type = \"mean\",\n  metric = c(\"l2\", \"pearson\"),\n  cluster_on_phase = FALSE\n)\n```\n:::\n\n\n## What about boys and girls?\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n| Cluster|female      |male        |\n|-------:|:-----------|:-----------|\n|       1|8.33%  (3)  |91.67% (33) |\n|       2|89.47% (51) |10.53%  (6) |\n\n\n:::\n:::\n\n\n## References\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}